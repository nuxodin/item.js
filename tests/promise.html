<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Test</title>
<body>

<h1>Test</h1>

<script type=module>

import {Item} from "../item.js";

class PomiseItem extends Item {

    trustSendingValue = true;
    cacheDuration = 2000; // cache for 2 seconds, false = no cache, true = cache forever
    expectedValue = null;
    setterPromise = null;
    getterPromise = null;

    constructor(parent, key) { super(parent, key); }

    createGetterPromise() { throw 'not implemented' }
    createSetterPromise(value) { throw 'not implemented' }

    #createGetterPromise() {
        const promise = this.createGetterPromise();
        makePromiseTransparent(promise);
        return promise;
    }
    #createSetterPromise(value) {
        const promise = abortablePromise((resolve, reject) => {
            return this.createSetterPromise(value).then(resolve, reject);
        });
        makePromiseTransparent(promise);
        return promise;
    }

    get value() {
        if (this.setterPromise?.state === 'pending' && this.trustSendingValue) return Promise.resolve(this.expectedValue); // trust sending value
        let promise = this.getterPromise;
        if (!promise) {
            promise = this.#createGetterPromise();
            const cache = this.cacheDuration;
            if (cache) {
                if (typeof cache === 'number') setTimeout(() => this.getterPromise = undefined, cache);
                this.getterPromise = promise;
            }
        }
        return promise;
    }
    set value(value) {
        if (this.setterPromise?.state === 'pending' && this.expectedValue === value) return; // ignore if sending value is the same
        if (this.getterPromise?.state === 'fulfilled' && this.getterPromise.value === value) return; // ignore if latest getter value is the same

        this.expectedValue = value;
        if (this.setterPromise) this.setterPromise.abort();

        const promise = this.#createSetterPromise(value);
        promise.then(data => {
            if (this.setterPromise !== promise) return; // ignore if setterPromise has been replaced (by another setter)
            this.getterPromise = null; // clear getter cache
            // todo, handle setter-promise result, on success, we can securly update the getter cache
            // if (data.savedValue) {
            //     this.getterPromise = Promise.resolve(data.savedValue); // update getter cache
            //     this.getterPromise.state = 'fulfilled';
            //     this.getterPromise.value = data.savedValue;
            // }
        }, err => {
            console.warn('setterPromise rejected: ' + err);
            if (this.setterPromise !== promise) return; // ignore if setterPromise has been replaced (by another setter)
            this.getterPromise = null; // clear getter cache
        }).finally(() => {
            this.setterPromise = null;
            this.expectedValue = null;
        });
        this.setterPromise = promise;
    }
}

// helper functions

/**
 * Adds state and value properties to a Promise, making it transparent.
 * @param {Promise} promise - The Promise to make transparent.
 */
function makePromiseTransparent(promise) {
    if (promise.state) console.warn('already transparent');
    promise.state = 'pending'; // or 'unknown' ?
    promise.value = undefined;
    promise.then(
        value => {
            promise.state = 'fulfilled';
            promise.value = value;
        },
        reason => {
            promise.state = 'rejected';
            promise.value = reason;
        }
    );
}

/**
 * Returns a delayed Promise that can be aborted within the specified time (ms).
 * @param {Function} fn - A function that returns a Promise.
 * @param {Number} [ms=1] - The time in milliseconds to delay before resolving the Promise.
 * @returns {Promise} - A delayed Promise that can be aborted.
 */
function abortablePromise(fn, ms=1) { // delayed and therfore abortable withing ms
    let aborted = false;
    const promise = new Promise((resolve, reject) => {
        setTimeout(() => {
            if (aborted) return resolve(null);
            fn(resolve, reject);
        }, ms);
    });
    promise.abort = () => aborted = true;
    promise.isAborted = () => aborted;
    return promise;
}


/*  test  */
/*  test  */

function delay(promise, ms) {
    const newPromise = new Promise(resolve => setTimeout(() => {
        promise.then(resolve);
    }, ms));
    return newPromise;
}


const promiseItem = new PomiseItem();
promiseItem.createGetterPromise = () => {
    console.warn('getterPromise requested' );
    return delay(Promise.resolve(Math.random()), 100);
}
promiseItem.createSetterPromise = value => {
    console.warn('setterPromise requested, value '+value );
    return delay(Promise.resolve({savedValue:'value from master'}), 100);
}


let actual = null;

actual = await promiseItem.value;
console.log('get value: ' + actual);

console.log('set value: ("val") ');
promiseItem.value = 'val';

console.log('set again same value');
promiseItem.value = 'val';

actual = await promiseItem.value;
console.log('get value: ("'+actual+'") ');

setTimeout(async () => {
    actual = await promiseItem.value;
    console.log('get againg after 50ms, trust setter while pending, value: ' + actual);
}, 50);

setTimeout(async () => {
    actual = await promiseItem.value;
    console.log('get againg after 2 seconds (getter is no more cached), value: ' + actual);
}, 2000);

setTimeout(async () => {
    actual = await promiseItem.value;
    console.log('get againg after 10ms (getter is cached), value: ' + actual);
}, 2010);

setTimeout(async () => {
    console.log('set value: ("val2") ');
    promiseItem.value = 'val2';

    console.log('set again: ("val3") ');
    promiseItem.value = 'val3';
}, 3000);

setTimeout(async () => {
    actual = await promiseItem.value;
    console.log('get value again: ' + actual);
}, 3100);


</script>

<div>
    <button onclick="random.value = Math.random().toString()">change cookie</button>
</div>